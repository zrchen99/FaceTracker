# -*- coding: utf-8 -*-
"""a4_q5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mbl5Re1vcl9ApdmZqlQSQfg9zfSdEJoG
"""

import cv2
import numpy as np
from matplotlib import pyplot as plt
from google.colab.patches import cv2_imshow

from google.colab import drive

# This will prompt for authorization.
drive.mount('/content/drive')



def iou(box1, box2):
  #x-coordinate, y-coordinate, width, height
  x1, y1, w1, h1 = box1
  x2, y2, w2, h2 = box2
  xA = max(x1, x2)
  yA = max(y1, y2)
  xB = min(x1 + w1, x2 + w2)
  yB = min(y1 + h1, y2 + h2)
  interArea = (xB - xA) * (yB - yA)
  boxAArea = w1 * h1
  boxBArea = w2 * h2
  iou = interArea / float(boxAArea + boxBArea - interArea)
  return iou

# cap = cv2.VideoCapture(0) # camera feed
cap = cv2.VideoCapture("/content/drive/My Drive/CSC420/A4/KylianMbappe.mp4") # video

# capture one frame
ret,frame = cap.read()

# detect a face on the first frame
face_detector = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml') 
face_boxes = face_detector.detectMultiScale(frame) 

if len(face_boxes)==0:
    print('no face detected')
    assert(False)

# initialize the tracing window around the (first) detected face
(x,y,w,h) = tuple(face_boxes[0]) 
track_window = (x,y,w,h)

#  region of interest for tracking
roi = frame[y:y+h, x:x+w]

# convert the roi to HSV so we can construct a histogram of Hue 
hsv_roi =  cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)

# why do we need this mask? (remember the cone?)
# read the description for Figure 3 in the original Cam Shift paper: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.7673 
mask = cv2.inRange(hsv_roi, np.array((0., 60.,32.)), np.array((180.,255.,255.)))


# form histogram of hue in the roi
roi_hist = cv2.calcHist([hsv_roi],[0],mask,[180],[0,180])

# normalize the histogram array values so they are in the min=0 to max=255 range
cv2.normalize(roi_hist,roi_hist,0,255,cv2.NORM_MINMAX)

# termination criteria for mean shift: 10 iteration or shift less than 1 pixel
term_crit = ( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 1 )

ious = []
low_frames = []
high_frames = []
min_frame = None
max_frame = None
max_iou = 0
min_iou = 1
frame_count = 1

while True:
    
    # grab a frame
    ret ,frame = cap.read() 
    frame_count += 1
    if ret == True: 
  
        # convert to HSV
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        
        # histogram back projection using roi_hist 
        dst = cv2.calcBackProject([hsv],[0],roi_hist,[0,180],1)
        
        # use meanshift to shift the tracking window
        ret, track_window = cv2.meanShift(dst, track_window, term_crit)
        
        # display tracked window
        x,y,w,h = track_window

        face_boxes = face_detector.detectMultiScale(frame)

        frame_iou = 0
        for face in face_boxes:
          face_iou = iou(face, track_window)
          if face_iou > frame_iou:
            frame_iou = face_iou
            x2, y2, w2, h2 = tuple(face)

        ious.append(frame_iou)
        if frame_iou < min_iou:
          min_iou = frame_iou
          min_frame = frame
        if frame_iou > max_iou:
          max_iou = frame_iou
          max_frame = frame
        
        if frame_iou > 0.7:
            high_frames.append(frame_count)
        if frame_iou < 0.5:
            high_frames.append(frame_count)
        
        img = cv2.rectangle(frame, (x2,y2), (x2+w2,y2+h2), (0,255,0),5)

        img = cv2.rectangle(img, (x,y), (x+w,y+h), (0,0,255),5)
        #Colab is having issues with cv2.imshow, I was forced to use this colab fixed version.
        cv2_imshow(img)

        
        if cv2.waitKey(33) & 0xFF == 27: # wait a bit and exit is ESC is pressed
            break
        
    else:
        break
        
cv2.destroyAllWindows()
cap.release()

plt.plot(np.arange(2, frame_count), ious)
plt.xlabel('Frame Number')
plt.ylabel('IoU')
plt.title('IoU over Time')
plt.show()
# plot the highest/lowest smaple frame
fig, axes = plt.subplots(1, 2, figsize=(15, 13))
max_frame = cv2.cvtColor(max_frame, cv2.COLOR_BGR2RGB)
min_frame = cv2.cvtColor(min_frame, cv2.COLOR_BGR2RGB)
axes[0].imshow(max_frame)
axes[1].imshow(min_frame)
axes[0].set_title('Highest IoU Sample')
axes[1].set_title('Lowest IoU Sample')

"""# **5.2 Simple Variation**"""

# cap = cv2.VideoCapture(0) # camera feed
cap = cv2.VideoCapture("/content/drive/My Drive/CSC420/A4/KylianMbappe.mp4") # video

# capture one frame
ret,frame = cap.read()

# detect a face on the first frame
face_detector = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml') 
face_boxes = face_detector.detectMultiScale(frame) 

if len(face_boxes)==0:
    print('no face detected')
    assert(False)

# initialize the tracing window around the (first) detected face
(x,y,w,h) = tuple(face_boxes[0]) 
track_window = (x,y,w,h)

#  region of interest for tracking
roi = frame[y:y+h, x:x+w]

# convert the roi to HSV so we can construct a histogram of Hue 
roi = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)
roi = cv2.GaussianBlur(roi, (5, 5), 1)
I_x = cv2.Sobel(roi, cv2.CV_64F, 1, 0, ksize=5)
I_y = cv2.Sobel(roi, cv2.CV_64F, 0, 1, ksize=5)
magnitude = np.zeros_like(I_x)
angle = np.zeros_like(I_x, dtype='uint8')
cv2.cartToPolar(I_x, I_y, magnitude, angle, angleInDegrees=True)

mask = cv2.inRange(magnitude, np.max(magnitude) * .1, np.inf)
gradient_hist = cv2.calcHist([angle], [0], mask, [24], [0, 360])
cv2.normalize(gradient_hist, gradient_hist, 0, 360, cv2.NORM_MINMAX)

# termination criteria for mean shift: 10 iteration or shift less than 1 pixel
term_crit = ( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 1 )

ious = []
low_frames = []
high_frames = []
min_frame = None
max_frame = None
max_iou = 0
min_iou = 1
frame_count = 1

while True:
    
    # grab a frame
    ret ,frame = cap.read() 
    frame_count += 1
    if ret == True: 
  
        # convert to HSV
        gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        gray_frame = cv2.GaussianBlur(gray_frame, (5, 5), 1)
        I_x = cv2.Sobel(gray_frame, cv2.CV_32F, 1, 0, ksize=5)
        I_y = cv2.Sobel(gray_frame, cv2.CV_32F, 0, 1, ksize=5)

        frame_mag, frame_angle = cv2.cartToPolar(I_x, I_y, angleInDegrees=True)
        threshold = frame_mag < (np.max(frame_mag)* 0.1)
        frame_angle[threshold] = 0
        

        # histogram back projection using roi_hist 
        dst = cv2.calcBackProject([frame_angle],[0],gradient_hist,[0,360],1)
        
        # use meanshift to shift the tracking window
        ret, track_window = cv2.meanShift(dst, track_window, term_crit)
        
        # display tracked window
        x,y,w,h = track_window


        face_boxes = face_detector.detectMultiScale(frame)

        frame_iou = 0
        for face in face_boxes:
          face_iou = iou(face, track_window)
          if face_iou > frame_iou:
            frame_iou = face_iou
            x2, y2, w2, h2 = tuple(face)

        ious.append(frame_iou)
        if frame_iou < min_iou:
          min_iou = frame_iou
          min_frame = frame
        if frame_iou > max_iou:
          max_iou = frame_iou
          max_frame = frame
        
        if frame_iou > 0.7:
            high_frames.append(frame_count)
        if frame_iou < 0.5:
            high_frames.append(frame_count)
        
        img = cv2.rectangle(frame, (x2,y2), (x2+w2,y2+h2), (0,255,0),5)

        img = cv2.rectangle(img, (x,y), (x+w,y+h), (0,0,255),5)
        #Colab is having issues with cv2.imshow, I was forced to use this colab fixed version.
        cv2_imshow(img)

        
        if cv2.waitKey(33) & 0xFF == 27: # wait a bit and exit is ESC is pressed
            break
        
    else:
        break
        
cv2.destroyAllWindows()
cap.release()

plt.plot(np.arange(2, frame_count), ious)
plt.xlabel('Frame Number')
plt.ylabel('IoU')
plt.title('IoU over Time')
plt.show()
# plot the highest/lowest smaple frame
fig, axes = plt.subplots(1, 2, figsize=(15, 13))
max_frame = cv2.cvtColor(max_frame, cv2.COLOR_BGR2RGB)
min_frame = cv2.cvtColor(min_frame, cv2.COLOR_BGR2RGB)
axes[0].imshow(max_frame)
axes[1].imshow(min_frame)
axes[0].set_title('Highest IoU Sample')
axes[1].set_title('Lowest IoU Sample')
print('Note: The Tracked Box is in Red; The Detected Box is in Green')